
require 'fileutils'


$start_pwd = Dir.pwd
$start_pwd.freeze
$script_path = File.expand_path __FILE__
$script_path.freeze


# We put parameters that are just related to this script
# in $par, because we do not need OO programing all the time.
$par = Hash.new

######################################################################
# default values
######################################################################


# lists of GNU make files to insert into GNUmakefile(s)

# number of GNUmakefile(s) written
$GNUmakefile_count = 0

######################################################################
#
# Okay: no more (non-method) globals added after this point
#
######################################################################


def dumpFile(in_path, out_file, required = true)

    if required or File.exist? in_path
        out_file.print '#>>>>> BEGIN FILE: ' + in_path + "\n"
        $pkg.sub_strings(in_path, out_file)
        out_file.print '#<<<<< END   FILE: ' + in_path + "\n"
    else
        out_file.print "\n# no file: " + in_path + " to add\n\n"
    end
end

# dir is path to write GNUmakefile
# top_builddir is how to get to top build dir from dir, like . or .. or ../..
# rel_srcdir is the directory name from the top source dir like:
#     '', '/tests', '/tests/lib'  note we prefix with a '/'
#     so the rel_srcdir of '' is relative path '.'
#
def mkMakefile(dir, top_builddir, rel_srcdir, subdirs)

    if $GNUmakefile_count > 1000
        # Seems like too many make files to me.
        puts 'STOPPING at ' + $GNUmakefile_count.to_s +
            ' GNUmakefile make files'
        exit 1
    end

    mfile = dir + '/' + 'GNUmakefile'

    if File.exist? mfile
        puts '    regenerating: ' + mfile
    else
        puts '      generating: ' + mfile
    end
    
    if $par[:top_build_is_top_src]
        # We can use relative paths we are building from the
        # top source directory.  That way we can move the tree
        # and not brake the make files.
        srcdir = '.'
        top_srcdir = top_builddir
    else
        srcdir = $par[:top_srcdir] + rel_srcdir
        top_srcdir = $par[:top_srcdir]
    end

    f = File.open(mfile, "w")

    if subdirs.length > 0
        subdirs_makecode = <<-END.gsub(/^ {12}/, '')
            # Run make in sub-directories
            subdirs := #{subdirs.join(' ')}
        END
    else
        subdirs_makecode = <<-END.gsub(/^ {12}/, '')
            # This directory has no sub-directories
            # so subdirs is not defined
        END
    end

    command = __FILE__ + $argOpts

    # qb_srcs = quickbuild qb.make source files
    # at the time this script ran
    qb_make = $par[:top_srcdir] + rel_srcdir + '/qb.make'

    qb_srcs = ''
    qb_srcs = ' ' + srcdir + '/qb.make' if File.exist? qb_make
    
    dist_clean_files = 'GNUmakefile'



    if top_builddir == '.'
         dist_clean_files += ' qb_config qb_php_compile'
        if $pkg[:info][:CONFIG_H]
            dist_clean_files += ' ' + $pkg[:info][:CONFIG_H]
        end
        rebuild_command = ''
        if $pkg[:info][:CONFIG_H]
            built_sources = $pkg[:info][:CONFIG_H]
        else
            built_sources = ''
        end
    else
        rebuild_command = "cd $(top_builddir) &&\\\n "
        built_sources = ''
    end

    rebuild_command += $pkg.get_rerun_command + "\\\n " + $par[:rerun_options]


    qb_core_files = "\\\n " + $script_path + "\\\n " + File.dirname($script_path) + '/qb_php_compile'

    if $par[:package_info_path]
        if $par[:top_build_is_top_src] and $par[:package_info_rel_top_srcdir_path]
            qb_core_files += "\\\n " + top_srcdir + '/' + $par[:package_info_rel_top_srcdir_path]
        else
            qb_core_files += "\\\n " + $par[:package_info_path]
        end
    end


    poundStr =
    '#####################################################################'


    f.write <<-END
# This is a generated file, DO NOT EDIT IT
# This is a GNU makefile with GNU make extensions
# This file (and many other files) is (are) generated by running:
#  #{command}
#  from the directory: #{$start_pwd}

#{poundStr}

# top build directory, like: . or .. or ../.. or ../../.. etc
top_builddir := #{top_builddir}

# Full path to the #{$pkg[:info][:NAME]} source directory tree
top_srcdir := #{top_srcdir}

# corresponding source directory in the source directory tree
srcdir := #{srcdir}

#{subdirs_makecode}

# A re-run of quickbuild should work even if the top build directory is
# moved. 
qb_rebuild_command :=\\
 #{rebuild_command}

# initialize built_sources.  We will append it later.
built_sources := #{built_sources}

# We let the development depend on changes in the quickbuild build system
# files so that a minor edit to a quickbuild file does not require the
# developer to start over, in a sense.  Also we want the removal of
# non-core source quickbuild files to not brake the make files that exist.

# The full path to files for this quickbuild build system are:
qb_core_files :=#{qb_core_files}

# All the files of this quickbuild build system as used in
# package #{$pkg[:info][:NAME]}
# at the time that this file was generated are:
qb_srcs =#{qb_srcs}

#{poundStr}
# initialize

#{poundStr}
#   Package and Configured parameters


dist_clean_files = #{dist_clean_files}

# top_build_is_top_src is defined if we are building in the top source directory
END


    if $par[:top_build_is_top_src]
        f.write "top_build_is_top_src := yes\n\n"
    else
        f.write "# top_build_is_top_src is not defined for this build\n\n"
    end

    if top_builddir == '.'
        if $par[:no_dist] or $pkg[:info][:NO_DIST]
            f.write "no_dist_files :="
            f.write " #{$par[:no_dist]}" if $par[:no_dist]
            f.write " #{$pkg[:info][:NO_DIST]}" if $pkg[:info][:NO_DIST]
        else
            f.write "# no_dist_files was not defined"
        end
        f.write "\n"
    end 


    f.write poundStr + "\n"
    $pkg.gen_make(f)
    f.write poundStr + "\n"

    if ENV['CFLAGS']
        f.write "# CFLAGS from environment when quickbuild ran\n" +
            'cflags := ' + ENV['CFLAGS'] + "\n"
    else
        f.write "# quickbuild default CFLAGS\n" +
            "cflags := -Wall -Werror -g\n"
    end
    if ENV['CPPFLAGS']
        f.write "# CPPFLAGS from environment when quickbuild ran\n" +
            'cppflags := ' + ENV['CPPFLAGS'] + "\n"
    else
        f.write "# CPPFLAGS was not set in the " +
             "environment when quickbuild ran\n"
    end


    f.write poundStr + "\n"

    dumpFile(qb_make, f, false)

    unless defined? $makefile_DATA
        $makefile_DATA = DATA.read
    end
    f.write $makefile_DATA

    $GNUmakefile_count += 1
end



def mkMirrorAndMakefiles(from_dir, to_pwd, top_builddir, rel_srcdir)

    unless File.exist? to_pwd
        puts 'making directory: ' + to_pwd + '/'
        FileUtils.mkdir_p to_pwd
    end


    # Gets the contents of SUBDIRS from qb.make if it exists
    subdirs = []

    if File.exist?(from_dir + '/qb.make')
        # make a temporary GNUmakefile
        gpath = to_pwd + '/GNUmakefile.tmp_zZ'
        exists = File.exist?(gpath)
        f = File.open(gpath, "w")
        f.write <<-END
# Temporary GNU makefile used to get value of SUBDIRS
include #{from_dir + '/qb.make'}
undefine build
ifeq ($(strip $(SUBDIRS)),)
SUBDIRS :=
endif
test__subdirs_FASDiefjmzzz:
        END

        f.write "\t@echo \"@@@@$(strip $(SUBDIRS))####\"\n"
        f.close

        run = "make -C #{to_pwd} --silent -f GNUmakefile.tmp_zZ " +
            "test__subdirs_FASDiefjmzzz"
        # We found that there can be extra spew in the output of GNU make
        # even with --silent, if this is run from another make process,
        # so we look for a string between @@@@ and ####.
        out = %x[#{run}]
        # run error check
        unless $?.success?
            # make failed
            $stderr.print <<-END
  configure failed: running:
    #{run}
  FAILED
            END
            exit 1
        end
        #$stderr.print 'subdirs ="' + subdirs.to_s + "\"\n"
        File.unlink gpath unless exists

        out.each_line do |s|
            if s =~ /@@@@.*####/
                subdirs = s.gsub(/(^.*@@@@|####.*$)/,'').split
                break
            end
        end
    end
 

    if subdirs.empty?
        Dir.glob(from_dir + '/*').each do |dir|
            next if not File.directory? dir
            if $pkg[:info][:SKIP_DIRS]
                got = false
                Dir.glob($pkg[:info][:SKIP_DIRS]).each do |d|
                    if File.basename(dir) == File.basename(d)
                        got = true
                        break
                    end
                end
                next if got
            end
            subdirs.push(File.basename(dir))
        end
    end
    
    ##$stderr.print 'WTF subdirs = "' + subdirs.to_s + "\"\n"
    ##exit 1 if subdirs.length > 2

    mkMakefile(to_pwd, top_builddir, rel_srcdir, subdirs)

    unless top_builddir == '.'
        top_builddir += '/..'
    else
        top_builddir = '..'
    end

    subdirs.each do |d|
        if d != '.'
            mkMirrorAndMakefiles(from_dir + '/' + d, to_pwd +
                             '/' + d, top_builddir, rel_srcdir + '/' + d)
        end
    end

end



def configure (pkg_args)

    $par[:quickbuild_path] = File.expand_path __FILE__

    unless File.exist? $par[:package_info_path]
        $stderr.print "No quickbuild package info file (qb.package_info) found.\n" +
            "Looking for: #{$par[:package_info_path]}\n"
        if $par[:package_info_set]
            $stderr.print <<-END.gsub(/^ {12}/,'')
            option: --package-info-path=#{$par[:package_info_set]} FAILED

            END
            exit 1
        end
        $par[:package_info_path] = nil
    end

    if $par[:package_info_path]
        puts "         reading: #{$par[:package_info_path]}\n"
    end

    $par[:build_pwd] = File.expand_path $par[:build_prefix]

    FileUtils.mkdir_p $par[:build_pwd] unless File.exist? $par[:build_pwd]
    Dir.chdir $par[:build_pwd]
    $par[:build_pwd] = Dir.pwd

    # We are now running in the top build directory
    
    $par[:top_srcdir] = File.expand_path $par[:top_srcdir]
    Dir.chdir $par[:top_srcdir]
    $par[:top_srcdir] = Dir.pwd
    Dir.chdir $par[:build_pwd]

    # We are now running in the top build directory

    package_info_defaults = {
            # set default package name to the top srcdir name
            :NAME => File.basename($par[:top_srcdir]).gsub(/[^a-zA-Z0-9_]/, '')
            #:NAME => File.basename($par[:top_srcdir]).gsub(/ /, '')
        }


    $pkg = QBPackage.new($par[:package_info_path], pkg_args, package_info_defaults)


    $stderr.print <<-END unless File.exist? $par[:top_srcdir] + '/qb.make'
No file named qb.make was found in #{$par[:top_srcdir]}
    END

    $par[:rerun_options] = '--src-prefix=' + $par[:top_srcdir]

    
    if $par[:top_srcdir] == $par[:build_pwd]
        $par[:top_build_is_top_src] = true
    else
        $par[:top_build_is_top_src] = false
    end

    if $par[:package_info_path]
        if $par[:top_build_is_top_src]
            $par[:rerun_options] += "\\\n --package-info=" +
                $par[:package_info_rel_top_srcdir_path]
        else
            $par[:rerun_options] += "\\\n --package-info=" +
                $par[:package_info_path]
        end
    end
    $par[:rerun_options] += "\\\n --no-dist=\"#{$par[:no_dist]}\"" if $par[:no_dist]



    if File.exist? 'qb_config'
        puts "    regenerating: #{$par[:build_pwd]}/qb_config"
    else
        puts "      generating: #{$par[:build_pwd]}/qb_config"
    end

    $pkg.gen_sub_prog('qb_config')

    
    if File.exist? 'qb_php_compile'
        puts "    regenerating: #{$par[:build_pwd]}/qb_php_compile"
    else
        puts "      generating: #{$par[:build_pwd]}/qb_php_compile"
    end

    FileUtils.copy(File.dirname($script_path) + '/qb_php_compile', $par[:build_pwd])



    #############################################################
    # make configure header file or not
    #############################################################
    if $pkg[:info][:CONFIG_H]

        path = $par[:build_pwd] + '/' + $pkg[:info][:CONFIG_H]

        if File.exist? path
            puts "    regenerating: " + path
        else
            puts "      generating: " + path
        end

        $pkg.gen_config_h($pkg[:info][:CONFIG_H])
    end

    mkMirrorAndMakefiles($par[:top_srcdir], $par[:build_pwd], '.', '')


    #    -------------------- CAUTION -----------------------
    #
    # CAUTION: Do not make any more files non-GNUmakefile files after
    # making any of the GNUmakefile files.  It would make 'make' go into
    # an infinite recursion loop, since all GNUmakefile files depend on
    # all the other quickbuild makes in GNUmakefile and running this
    # script makes the GNUmakefile files and other quickbuild files.

end


def help_printOpt(f, pre, text)

    max = 76 # length of printed text line
    spaces = "                         " # indent
    indent = spaces.length
    charPerLine = max - indent
    itext = 0 # test index printed so far
    textLen = text.length

    pre = "  " + pre

    f.print pre

    if pre.length < indent
        # pad to indent position
        f.print spaces[0, indent - pre.length]
        f.print text[0, charPerLine]
        itext += charPerLine
    end

    f.print "\n"

    while itext < textLen do
        f.printf spaces + text[itext, charPerLine] + "\n"
        itext += charPerLine
    end

    f.print "\n"
end


def usage(pkg_args)


    # TODO: fix the line breaks so that printing is neater
    # It's harder to do given that #{pkg.name} has
    # a variable character length.
   
    $par[:package_info_path] = nil unless File.exist? $par[:package_info_path]

    pkg = QBPackage.new($par[:package_info_path], pkg_args)

    $stdout.print <<END
  
  Usage: #{File.basename __FILE__} [--build-prefix BPATH][--src-prefix SPATH]\\
        [--package-info IFILE][#{pkg.name}_PACKAGE_OPTIONS]|[-h|--help]|\\
        [-V|--version]

  Generates GNUmakefile make files and build scripts in the build path.
  All command-line paths may be relative paths.
   
                 OPTIONS

  --build-prefix BPATH    directory path where to build #{pkg.name}.  The
                          default is the current working directory when this
                          script is run. PATH should not have a trailing
                          slash (/).


  --src-prefix SPATH      directory path where the top source directory is.
                          The default SPATH is the current working directory.


  --package-info IFILE   set the path to the quickbuild package information
                         ruby script file.  The default is:
                          
                              SPATH/qb.package_info


  --help|-h              print this help and exit


  --version|-V           print the quickbuild version number (#{$qb_version})
                         and exit.
                         

 
        
                
                #{pkg.name}_PACKAGE_OPTIONS


END

    pkg.get_user_usage_config_opts($stdout)

    $stdout.write "\n\n"

    # An error case will throw an exception, but maybe usage should always
    # return error; no, usage is aways intentional for this program.

    exit 0

end


def check_arg(name, arg)

    if arg == name

        arg = ARGV.shift
        usage unless arg
        $argOpts += ' ' + arg
        return arg
    end

    regexp = Regexp.new '^' + name + '='

    if arg =~ regexp
        return arg.sub(regexp, '')
    end

    return false
end


def parse_args

    pkg_args = [ ]
    $par[:package_info_set] = false
    $par[:package_info_rel_top_srcdir_path] = false
    $par[:no_dist] = false
    got_usage = false


    arg = ARGV.shift
    $argOpts = ''
    $rebuildArgOpts = ''

    # defaults
    $par[:build_prefix] = '.' # relative path is better
    $par[:top_srcdir] = File.expand_path '.' # not here


    while arg

        $argOpts += ' ' + arg

        
        if (ret = check_arg('--build-prefix', arg))
            $par[:build_prefix] = ret
        elsif (ret = check_arg('--no-dist', arg))
            $par[:no_dist] = ret
        elsif (ret = check_arg('--src-prefix', arg))
            $par[:top_srcdir] = File.expand_path ret
        elsif (ret = check_arg('--package-info', arg))
            $par[:package_info_set] = ret
        elsif arg == '-h' or arg == '--help'
            got_usage = true
        elsif arg == '-V' or arg == '--version'
            puts $qb_version
            exit 0
        else
            pkg_args << arg
        end

        arg = ARGV.shift
    end



    if $par[:package_info_set]
        $par[:package_info_path] = File.expand_path $par[:package_info_set]
        regexp = Regexp.new '^' + Regexp.escape($par[:top_srcdir]) + '\/'
        if $par[:package_info_path] =~ regexp
            # package info file is somewhere in the source tree
            $par[:package_info_rel_top_srcdir_path] = $par[:package_info_path].sub(regexp, '')
        end
    else
        # default value
        $par[:package_info_path] = $par[:top_srcdir] + '/qb.package_info'
        $par[:package_info_rel_top_srcdir_path] = 'qb.package_info'
    end


    usage pkg_args if got_usage

    if %x[make --version][0,9] != 'GNU Make '
        $stderr.print "GNU is not in your PATH\n"
        exit 1
    end

    pkg_args

end

configure parse_args

